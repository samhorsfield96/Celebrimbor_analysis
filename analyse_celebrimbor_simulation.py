import argparse


def get_options():
    description = 'Matches pangenome assignments from CELEBRIMBOR pre and post simulation (assumes remove_sequence.py has been run).'
    parser = argparse.ArgumentParser(description=description,
                                     prog='python analyse_celebrimbor_simulation.py')

    IO = parser.add_argument_group('Input/Output options')
    IO.add_argument('--matched-genes',
                    default=None,
                    required=True,
                    help='.tsv file generated from match_genes.py')
    IO.add_argument('--cgt-pre',
                    default=None,
                    required=True,
                    help='cgt_output.txt file generated by CELEBRIMBOR for PRE-simulation dataset.')
    IO.add_argument('--cgt-post',
                default=None,
                required=True,
                help='cgt_output.txt file generated by CELEBRIMBOR for POST-simulation dataset.')
    IO.add_argument('--checkm-pre',
            default=None,
            required=True,
            help='checkm_out.tsv file generated by CELEBRIMBOR for PRE-simulation dataset.')
    IO.add_argument('--checkm-post',
            default=None,
            required=True,
            help='checkm_out.tsv file generated by CELEBRIMBOR for POST-simulation dataset.')
    IO.add_argument('--pan-pre',
            default=None,
            required=True,
            help='pangenome_summary.tsv file generated by CELEBRIMBOR for PRE-simulation dataset.')
    IO.add_argument('--pan-post',
            default=None,
            required=True,
            help='pangenome_summary.tsv file generated by CELEBRIMBOR for POST-simulation dataset.')
    IO.add_argument('--mmseqs-pre',
            default=None,
            required=True,
            help='mmseqs_cluster.sorted.tsv file generated by CELEBRIMBOR for PRE-simulation dataset.')
    IO.add_argument('--mmseqs-post',
            default=None,
            required=True,
            help='mmseqs_cluster.sorted.tsv file generated by CELEBRIMBOR for POST-simulation dataset.')
    IO.add_argument('--outpref',
                    default="celebrimbor_results",
                    help='Output prefix. Default = "celebrimbor_results"')

    return parser.parse_args()

def main():
    options = get_options()
    matched_genes = options.matched_genes
    cgt_pre = options.cgt_pre
    cgt_post = options.cgt_post
    checkm_pre = options.checkm_pre
    checkm_post = options.checkm_post
    pan_pre = options.pan_pre
    pan_post = options.pan_post
    outpref = options.outpref

    # testing
    matched_genes = "test_gene_matching.tsv"
    cgt_pre = "data/cgt_test/cgt_output_ori.txt"
    cgt_post = "data/cgt_test/cgt_output_sim.txt"
    checkm_pre = "data/cgt_test/checkm_out_ori.tsv"
    checkm_post = "data/cgt_test/checkm_out_sim.tsv"
    pan_pre = "data/cgt_test/pangenome_summary_ori.tsv"
    pan_post = "data/cgt_test/pangenome_summary_sim.tsv"
    outpref = "celebrimbor_results"

    # get matched genes, key is gene from simulation
    matched_genes = {}
    with open(matched_genes, "r") as f:
        next(f)
        for line in f:
            split_line = line.rstrip().split("\t")
            matched_genes[split_line[1]] = split_line[0]
    

    # parse cgt outputs
    cgt_pre_dict = {}
    with open(cgt_pre, "r") as f:
        next(f)
        for line in f:
            split_line = line.rstrip().split("\t")
            # key is gene, first entry is count, second is frequency label
            cgt_pre_dict[split_line[0]] = (split_line[1], split_line[2])
    
    cgt_post_dict = {}
    with open(cgt_post, "r") as f:
        next(f)
        for line in f:
            split_line = line.rstrip().split("\t")
            # key is gene, first entry is count, second is frequency label
            cgt_post_dict[split_line[0]] = (split_line[1], split_line[2])

    # parse 

    # output completeness file
    with open(output + ".tsv", "w+") as f:
        f.write("Pre-sim_gene\tPost-sim_gene\n")
        for entry in gene_mappings:
            f.write(str(entry[0]) + "\t" + str(entry[1]) + "\n")
            

if __name__ == "__main__":
    main()