import argparse
import json
import pandas as pd
import numpy as np

def get_options():
    description = 'Generates ORFs from a Bifrost graph.'
    parser = argparse.ArgumentParser(description=description,
                                     prog='ggcaller')

    IO = parser.add_argument_group('Input/Output options')
    IO.add_argument('--pa-file',
                    default=None,
                    required=True,
                    help='Gene presence/absence .csv file generated by generate_pa_matrix.py. ')
    IO.add_argument('--clusters',
                    default=None,
                    required=True,
                    help='Gene cluster .json file generated by generate_pa_matrix.py. ')
    IO.add_argument('--loc',
                    default=None,
                    required=True,
                    help='Gene location .json file generated by parse_gff.py. ')
    IO.add_argument('--dist',
                    default=None,
                    required=True,
                    help='Genome completeness distribution for sampling. ')
    IO.add_argument('--prop-complete',
                    default=0,
                    help='Proportion of complete genomes between 0-1. Default = 0. ')
    IO.add_argument('--outpref',
                    default="gene_pa",
                    help='Output prefix. Default = "gene_pa"')

    return parser.parse_args()

def main():
    options = get_options()
    pa_file = options.pa_file
    clusters = options.clusters
    locations = options.loc
    prop_complete = options.prop_complete
    dist_file = options.dist
    outpref = options.outpref

    # read in prop_complete, generate distribution
    dist_list = []
    with open(dist_file, "r") as f:
        for line in f:
            dist_list.append(float(line.rstrip()) / 100)

    dist_list = np.array(dist_list)

    #read pa_file
    pa_mat = pd.read_csv(pa_file)
    genome_index = {v: k for v, k in enumerate(pa_mat.index)}

    # determine complete genomes
    number_complete = round(len(genome_index) * prop_complete)

    # sample from distribution genomes at random
    incomplete_sample = np.random.choice(dist_list, size=(len(genome_index) - number_complete))
    completeness_array = np.full(len(genome_index), 1.0)

    # set random isolates to non-complete
    incomplete_genomes = np.random.choice(len(genome_index), size=incomplete_sample.size, replace=False)
    completeness_array[incomplete_genomes] = incomplete_sample


if __name__ == "__main__":
    main()